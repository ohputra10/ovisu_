{"mappings":"AAyBA;IACI,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,MAAM,CAAC,EAAE,MAAM,CAAC;CACnB;AAED;IACI,MAAM,EAAE,MAAM,CAAC;IACf,GAAG,CAAC,EAAC,MAAM,CAAC;IACZ,IAAI,CAAC,EAAE,MAAM,GAAC,SAAS,GAAC,IAAI,CAAC;IAC7B,IAAI,EAAE,YAAY,GAAC,MAAM,CAAC;IAC1B,IAAI,CAAC,EAAE,MAAM,GAAC,SAAS,GAAC,IAAI,CAAC;IAC7B,KAAK,CAAC,EAAE;QAAC,CAAC,GAAG,EAAC,MAAM,GAAE,MAAM,CAAA;KAAC,CAAC;IAC9B,QAAQ,CAAC,EAAE,MAAM,GAAC,SAAS,GAAC,IAAI,CAAC;CACpC;AEtCD;IACI,WAAW,CAAC,EAAE,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;IAChC,IAAI,CAAC,EAAE,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;IACzB,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,OAAO,CAAC,EAAE,MAAM,CAAC;IAEjB,IAAI,CAAC,EAAE,MAAM,CAAC;IACd,IAAI,CAAC,EAAE,MAAM,CAAC;CACjB;AAED;IACI,UAAU,EAAE,MAAM,CAAC;IACnB,QAAQ,EAAE,MAAM,CAAC;IACjB,IAAI,EAAE,MAAM,CAAC;CAChB;AAED;gBASgB,GAAG,EAAE,OAAO,EAAE,QAAQ,CAAC,EAAE,MAAM;IAqD3C,SAAS,IAAI,MAAM;IAInB,OAAO,IAAI,KAAK,CAAC,IAAI,CAAC,GAAG,SAAS;IAIlC,OAAO,IAAI,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS;IAIxC,aAAa,IAAI,MAAM,GAAG,SAAS;IAInC,UAAU,IAAI,MAAM,GAAG,SAAS;IAIhC,UAAU,IAAI,MAAM,GAAG,SAAS;IAIhC,SAAS,IAAI,MAAM,GAAG,SAAS;CAwElC;ACzKD;IACI,KAAK,EAAE,KAAK,CAAC,GAAG,CAAC,CAAC;IAClB,IAAI,EAAE,KAAK,CAAC,GAAG,CAAC,CAAA;IAChB,SAAS,EAAE,MAAM,CAAC;IAClB,IAAI,EAAE,GAAG,CAAC;IACV,KAAK,EAAE,IAAI,CAAC;gBAEA,OAAO,EAAE,GAAG;IAoBlB,KAAK,CAAC,GAAG,EAAE,MAAM,EAAE,IAAI,UAAO,GAAG,OAAO,CAAC,MAAM,CAAC;CAwBzD;ACrDD;;;;GAIG;AACH,iBAAyB,SAAQ,GAAG,EAAE,IAAI;IACtC,QAAQ,CAAC,EAAE,MAAM,GAAG,OAAO,CAAA;CAC9B;AAED;;;GAGG;AACH;IAEI,WAAW,EAAE,OAAO,CAAC;gBAET,UAAU,EAAE,OAAO;IAI/B,MAAM,IAAI,cAAc;CAI3B;AC1BD,OAAA,IAAI,SAAS,OAMZ,CAAA;AACD,OAAA,IAAI,kBAAmC,OAAO,cAG7C,CAAA","sources":["src/options.ts","src/request.ts","src/result.ts","src/cursor.ts","src/connect.ts","index.ts"],"sourcesContent":["import { Agent } from \"http\";\n\nexport interface FetchOptions {\n    // These properties are part of the Fetch Standard\n    method: string;\n     // request body. can be null, a string, a Buffer, a Blob, or a Node.js Readable stream\n    body: string;\n    // request headers.\n    headers: { [key: string]: string };//Record<string, string>;\n    // set to `manual` to extract redirect headers, `error` to reject redirect\n    redirect?: \"error\" | \"follow\" | \"manual\";\n    // pass an instance of AbortSignal to optionally abort requests\n    signal?: AbortSignal| null | undefined; \n    \n     // The following properties extensions\n    follow?: number|undefined;         \n    // req/res timeout in ms, it resets on redirect. 0 to disable (OS limit applies). Signal is recommended instead.\n    timeout?: number|undefined,         \n    // support gzip/deflate content encoding. false to disable\n    compress?: boolean|undefined;\n    // maximum response body size in bytes. 0 to disable\n    size?: number|undefined,            \n    agent?:Agent|undefined\n}\n\nexport interface User {\n    user?: string;\n    passwd?: string;\n}\n\nexport interface Uri {\n    scheme: string;\n    url?:string;\n    host?: string|undefined|null;\n    path: '/rest/sql/'|string;\n    port?: number|undefined|null;\n    query?: {[key:string]:string};\n    fragment?: string|undefined|null;\n}\n\n\n\n","\nimport { Uri, User, FetchOptions } from \"./options\";\nimport fetch from 'node-fetch';\n\nexport class TDResRequest {\n    uri: Uri;\n    options: FetchOptions;\n    user: User;\n    queryParams = '';\n    hashFragment = '';\n\n    constructor(uri: Uri, user: User) {\n        this.uri = uri;\n        this.user = user;\n\n        // if uri.url exists,and that is a cloud url(means token exist)\n        if ((uri.query && uri.query['token']) || (uri.query && uri.query['token'])) {\n            this.options = {\n                method: 'POST',\n                body: '',\n                headers: {},\n            }\n        } else {\n            this.options = {\n                method: 'POST',\n                body: '',\n                headers: { 'Authorization': this._token() },\n            }\n        }\n    }\n\n    _makeUrl(): string {\n        let url = '';\n        if (this.uri.url) {\n            this._constructUrlWithInput();\n        } else {\n            //do nothing \n        }\n        if (this.uri.port) {\n            url = `${this.uri.scheme}://${this.uri.host}:${this.uri.port}${this.uri.path}`\n        } else {\n            url = `${this.uri.scheme}://${this.uri.host}${this.uri.path}`\n        }\n        if (this.uri.query) {\n            url += '?'\n            Object.keys(this.uri.query).forEach(\n                key => {\n                    if (this.uri.query && (this.uri.query[key] || this.uri.query[key])) {\n                        url += key + \"=\" + this.uri.query[key] + \"&\"\n                    }\n                }\n            )\n            // remove last \"&\"\n            url = url.slice(0, url.length - 1);\n            // console.log(\"query param:\"+url)\n        }\n        if (this.queryParams) {\n            url += this.queryParams;\n        }\n\n        if ((this.uri.fragment) || (this.uri.fragment)) {\n            if (this.uri.fragment.slice(0, 1) == '#') {\n                url += this.uri.fragment\n            } else {\n                url += '#' + this.uri.fragment;\n            }\n        }\n        if (this.hashFragment) {\n            url += this.hashFragment;\n        }\n\n        //console.log(`url:${url}`);\n        return url;\n    }\n    // if user input url\n    _constructUrlWithInput() {\n        if (this.uri.url) {\n            let urlObj = new URL(this.uri.url);\n            if (urlObj.protocol) {\n                this.uri.scheme = urlObj.protocol.slice(0, urlObj.protocol.length - 1);;\n            }\n            if (urlObj.hostname) {\n                this.uri.host = urlObj.hostname;\n            }\n            if (urlObj.port) {\n                this.uri.port = parseInt(urlObj.port);\n            }\n            if (urlObj.pathname != '/') {\n                this.uri.path = urlObj.pathname;\n            }\n            if (urlObj.search) {\n                this.queryParams = urlObj.search;\n            }\n            if (urlObj.hash) {\n                this.hashFragment = urlObj.hash;\n            }\n        }\n    }\n\n    _token(): string {\n        return `Basic ${Buffer.from(`${this.user.user}:${this.user.passwd}`).toString('base64')}`\n    }\n    _body(command: string): void {\n        this.options.body = command;\n    }\n\n    request(command: string): Promise<any> {\n        this._body(command);\n        //console.log(this._makeUrl());\n        return fetch(this._makeUrl(), this.options);\n    }\n}\n\n\n","interface IResult {\n    column_meta?: Array<Array<any>>;\n    data?: Array<Array<any>>;\n    rows?: number;\n    command?: string;\n    //for error \n    code?: number;\n    desc?: string;\n}\n\ninterface meta {\n    columnName: string;\n    typeName: string;\n    size: number;\n}\n\nexport class Result {\n    private _column_meta?: Array<meta>;\n    private _data?: Array<Array<any>>;\n    private _rows?: number;\n    private _command?: string;\n    //for error \n    private _code?: number;\n    private _desc?: string;\n\n    constructor(res: IResult, commands?: string) {\n        let meta_list_length = res.column_meta == undefined ? 0 : res.column_meta.length\n        if(res.code == 0){\n            this._code = res.code;\n            if(res.data&&res.column_meta&&res.column_meta[0][0] === \"affected_rows\"){\n                this._rows = res.data[0][0]\n            }else if(res.data){\n                this._rows = res.data.length;\n            }\n            this._column_meta = new Array(meta_list_length);\n            this._initMeta(res);\n            this._data = res.data;\n            this._command = commands;\n            this._desc = undefined;\n        }else {\n            this._column_meta = undefined;\n            this._data = undefined;\n            this._rows = undefined;\n            this._command = commands;\n            this._code = res.code;\n            this._desc = res.desc;\n        }\n\n    }\n    private _initMeta(res: IResult): void {\n        if (res.column_meta != undefined) {\n            res.column_meta.forEach((item, index) => {\n                if (this._column_meta != undefined)\n                    this._column_meta[index] = {\n                        columnName: item[0],\n                        typeName: item[1],\n                        size: item[2],              \n                    }\n            })\n        }\n    }\n    private _initData(resData:Array<Array<any>>,meta:Array<Array<any>>,rows:number):void{\n        if (resData.length = 0){\n            this._data=[[]];\n        } else {\n            this._data= new Array<Array<any>>(resData.length);\n            for (let i =0 ;i<rows;i++){\n                for (let j=0;j<meta.length;j++){\n                    if(meta[j][1] ==9 ){\n                        this._data[i][j] = new Date(resData[i][j])\n                    }else{\n                        this._data[i][j] = resData[i][j]\n                    }\n                }\n            }\n        }\n    }\n\n    getResult(): Result {\n        return this;\n    }\n\n    getMeta(): Array<meta> | undefined {\n        return this._column_meta;\n    }\n\n    getData(): Array<Array<any>> | undefined {\n        return this._data;\n    }\n\n    getAffectRows(): number | undefined {\n        return this._rows;\n    }\n\n    getCommand(): string | undefined {\n        return this._command;\n    }\n\n    getErrCode(): number | undefined {\n        return this._code;\n    }\n\n    getErrStr(): string | undefined {\n        return this._desc;\n    }\n\n    // toString(): void {\n    //     let str = '';\n    //     if(this._command != undefined){\n    //         console.log(this._command);\n    //     }\n    //     if (this._code === 0 && this._column_meta  && this._data ) {\n    //          str = this._prettyStr(this._column_meta, this._data)\n    //     } else {\n    //         str = `Execute failed,reason:${this._desc}. error_no:${this._code} `;\n    //         console.log(str)\n    //     }\n    // }\n\n    private _prettyStr(fields: Array<meta>, data: Array<Array<any>>): string {\n        let colName = new Array<string>();\n        let colType = new Array<string | undefined>();\n        let colSize = new Array<number>();\n        let colStr = '';\n\n        for (let i = 0; i < fields.length; i++) {\n            colName.push(fields[i].columnName)\n            colType.push(fields[i].typeName);\n\n            if ((fields[i].typeName) === \"VARCHAR\" || (fields[i].typeName) === \"NCHAR\") {\n                colSize.push(Math.max(fields[i].columnName.length, fields[i].size));  //max(column_name.length,column_type_precision)\n            } else {\n                colSize.push(Math.max(fields[i].columnName.length, suggestedMinWidths[fields[i].size]));// max(column_name.length,suggest_column_with_suggestion)\n            }\n            // console.log(colSize)\n        }\n        colName.forEach((name, i) => {\n            colStr += this._fillEmpty(Math.floor(colSize[i] / 2 - name.length / 2)) + name.toString() + this._fillEmpty(Math.ceil(colSize[i] / 2 - name.length / 2)) + \" | \"\n        })\n\n        let strSperator = \"\"\n        let sizeSum = colSize.reduce((a, b) => a += b, (0)) + colSize.length * 3\n        strSperator = this._printN(\"=\", sizeSum)\n\n        console.log(\"\\n\" + colStr)\n        console.log(strSperator)\n\n        data.forEach((row) => {\n            let rowStr = \"\"\n            row.forEach((cell, index) => {\n                rowStr += cell == null ? 'null' : cell.toString();\n                rowStr += this._fillEmpty(colSize[index] - cell.toString().length) + \" | \"\n            })\n            console.log(rowStr)\n        })\n\n        return colStr\n    }\n\n    private _fillEmpty(n:number) {\n        let str = \"\";\n        for (let i = 0; i < n; i++) {\n            str += \" \";\n        }\n        return str;\n    }\n\n    private _printN(s:string, n:number) {\n        let f = \"\";\n        for (let i = 0; i < n; i++) {\n            f += s;\n        }\n        return f;\n    }\n}\n\n\n\ninterface indexableString {\n    [index: number]: string\n}\n/**\n * this file record TDengine's data type and code.\n */\nconst typeNameMap: indexableString = {\n    0: 'null',\n    1: 'bool',\n    2: 'tinyint',\n    3: 'smallint',\n    4: 'int',\n    5: 'bigint',\n    6: 'float',\n    7: 'double',\n    8: 'binary',\n    9: 'timestamp',\n    10: 'nchar',\n    11: 'unsigned tinyint',\n    12: 'unsigned smallint',\n    13: 'unsigned int',\n    14: 'unsigned bigint',\n    15: 'json'\n}\n\ninterface indexableNumber {\n    [index: number]: number\n}\nconst suggestedMinWidths: indexableNumber = {\n    0: 4,\n    1: 4,\n    2: 4,\n    3: 6,\n    4: 11,\n    5: 12,\n    6: 24,\n    7: 24,\n    8: 10,\n    9: 25,\n    10: 10,\n}\n\n\n","import { Uri, User } from './options'\nimport { TDResRequest } from './request'\nimport { Result } from './result'\n\n\nexport class TDengineCursor {\n    field: Array<any>;\n    data: Array<any>\n    _rowCount: number;\n    _uri: Uri;\n    _user: User;\n\n    constructor(options: any) {\n        this._uri = {\n            host: options.host,\n            path: options.path,\n            url: options.url,\n            port: options.port,\n            scheme: options.scheme,\n            query: options.query,\n            fragment: options.fragment,\n        }\n        this._user = {\n            user: options.user,\n            passwd: options.passwd,\n        }\n        this._rowCount = 0;\n        this.field = [];\n        this.data = [];\n\n    }\n\n    async query(sql: string, pure = true): Promise<Result> {\n        let req = new TDResRequest(this._uri, this._user);\n        let response = await req.request(sql);\n        if (response.status == 200) {\n            let res_json = await response.json();\n            if (pure == false) {\n                return new Result(res_json, sql);\n            } else {\n                return new Result(res_json);\n            }\n\n        } else if (response.status == 400) {\n            new Error(\"invalid parameters.\")\n        } else if (response.status == 401) {\n            throw new Error(\"Authentication failed.\")\n        } else if (response.status == 404) {\n            throw new Error(\"interface not exists.\")\n        } else if (response.status == 500) {\n            throw new Error(\"internal error.\")\n        } else if (response.status == 503) {\n            throw new Error(\"insufficient system resource.\")\n        }\n        throw new Error(\"http request failed.\");\n    }\n}","import { TDengineCursor } from './cursor'\nimport { Uri, User } from './options'\n\n/**\n * Options used to connect with REST(taosAdapter)\n * Need to set options with 'host','path','port','user','passwd'.\n * connWith is optional attribute for further use.\n */\nexport interface Options extends Uri, User {\n    connWith?: 'rest' | 'taosc'\n}\n\n/**\n * Create connect with TDengine,actually pass options \n * to `Cursor` which send and receive HTTP request.\n */\nexport class TDConnect {\n\n    _connOption: Options;\n\n    constructor(connOption: Options) {\n        this._connOption = connOption\n    }\n\n    cursor(): TDengineCursor {\n        return new TDengineCursor(this._connOption);\n    }\n\n}\n","\nimport { TDConnect, Options } from './src/connect';\nlet options: Options = {\n    path: '/rest/sql/',\n    scheme: 'http',\n    user: 'root',\n    passwd: 'taosdata',\n    host: \"127.0.0.1\",\n}\nlet connect = function connect(option: Options) {\n    // console.log(\"index.options:\"+JSON.stringify(option));\n    return new TDConnect(option);\n}\n\nexport { options, connect }\n"],"names":[],"version":3,"file":"types.d.ts.map"}